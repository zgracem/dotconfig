{
  // basics

  "(set: ...VariableToValue) → Instant": {
    "prefix": "set:",
    "body": "(set: ${1|num,number,str,string,bool,boolean,array,dm,datamap,ds,dataset,command,changer,colour,color,gradient,lambda,macro,datatype,codehook,even,odd,int,integer,empty,whitespace,lowercase,uppercase,anycase,alnum,alphanumeric,digit,newline,linebreak,const,any|}-type ${2:\\$varName} to ${0:value})",
    "description": "Stores data values in variables."
  },
  "(put: ...VariableToValue) → Instant": {
    "prefix": "put:",
    "body": "(put: ${0:value} into ${1:\\$varName})",
    "description": "A left-to-right version of `(set:)`."
  },
  "(move: ...VariableToValue) → Instant": {
    "prefix": "move:",
    "body": "(move: ${1:\\$array's 1st} into ${0:\\$var})",
    "description": "A variant of `(put:)` that transfers data from a data structure, deleting the source value after copying it."
  },
  "(print: Any) → Command": {
    "prefix": "print:",
    "body": "(print: ${0:\\$var + \"s\"})",
    "description": "Prints out any data provided to it, as text."
  },
  "(display: String) → Command": {
    "prefix": "display:",
    "body": "(display: ${1:\"${0:Cellar}\"})",
    "description": "Writes out the contents of the passage with the given string name."
  },
  "(if: Boolean) → Changer": {
    "prefix": "if:",
    "body": "(if: ${1:condition})[$0]",
    "description": "Accepts only booleans, and produces a changer that can be attached to hooks to hide them if the value was false."
  },
  "(unless: Boolean) → Changer": {
    "prefix": "unless:",
    "body": "(unless: ${1:condition})[$0]",
    "description": "The negated form of `(if:)`."
  },
  "(else-if: Boolean) → Changer": {
    "prefix": "else-if:",
    "body": "(else-if: ${1:condition})[$0]",
    "description": "This macro's result changes depending on whether the previous hook in the passage was shown or hidden."
  },
  "(else:) → Changer": {
    "prefix": "else:",
    "body": "(else:)[$0]",
    "description": "Will show the attached hook if the preceding hook was hidden, and hide it otherwise."
  },
  "(for: eachLambda, [...Any]) → Changer": {
    "prefix": ["for:", "loop:", "for-each:"],
    "body": "(for: each ${1:_item}, ${3:...${2:\\$array}})[${0:You have the _item.}]",
    "description": "Repeats the attached hook, setting a temporary variable to a different value on each repeat."
  },
  "(for: whereLambda, [...Any]) → Changer": {
    "prefix": ["for:", "loop:", "for-where:"],
    "body": "(for: ${1:_ingredient} where ${2:it contains \"oil\"}, ${4:...${3:\\$ingredients}})[${0:Cook the _ingredient?}]",
    "description": "Repeats the attached hook, setting a temporary variable to a different value on each repeat."
  },
  "(either: ...Any) → Any": {
    "prefix": "either:",
    "body": "(either: ${2:...${1:\\$array}})",
    "description": "Takes several values separated by commas, and returns one of them randomly."
  },
  "(cond: Boolean, Any, ...Any) → Any": {
    "prefix": "cond:",
    "body": "(cond: ${1:condition}, ${2:_ifTrue}, ${3:_ifFalse})",
    "description": "Returns the first value paired with a true condition from a sequence of booleans paired with values."
  },
  "(nth: Number, ...Any) → Any": {
    "prefix": "nth:",
    "body": "(nth: ${1:\\$num}, ${3:...${2:\\$array}})",
    "description": "Given a positive whole number `n` and a sequence of values, this selects the `n`th value in the sequence."
  },
  "(verbatim:) → Changer": {
    "prefix": ["v6m:", "verbatim:"],
    "body": "(v6m:)[$0]",
    "description": "Render the attached hook or command as plain text instead of HTML."
  },
  "(verbatim-print: Any) → Command": {
    "prefix": ["v6m-print:", "verbatim-print:"],
    "body": "(v6m-print: ${0:\"<em>Hello</em>\"})",
    "description": "Prints out any single argument given to it as text, without rendering the resulting text as markup."
  },
  "(change: HookName or String, Changer or Lambda) → Command": {
    "prefix": "change:",
    "body": "(change: ${1:?target}, ${0:(colour: red)})",
    "description": "Applies a changer (or `via` lambda) to every occurrence of a hook or string in a passage, once."
  },
  "(enchant: HookName or String, Changer or Lambda) → Command": {
    "prefix": "enchant:",
    "body": "(enchant: ${1:?target}, ${0:(colour: red)})",
    "description": "Applies a changer (or `via` lambda) to every occurrence of a hook or string in a passage, and to any future occurrences in the same passage."
  },
  "(enchant-in: HookName or String, Changer or Lambda) → Changer": {
    "prefix": "enchant-in:",
    "body": "(enchant-in: ${1:?target}, ${0:(colour: red)})",
    "description": "Applies a changer to every occurrence of a hook or string within the attached hook."
  },
  "(hooks-named: String) → HookName": {
    "prefix": "hooks-named:",
    "body": "(hooks-named: ${1:\"${0:door}\"})",
    "description": "When given a string, this creates a HookName from it."
  },

  // borders

  "(border: String, [String], [String], [String]) → Changer": {
    "prefix": ["b4r:", "border:"],
    "body": "(border: \"${1|none,solid,dotted,dashed,double,groove,ridge,inset,outset|}\")",
    "description": "A changer macro that applies a CSS border to the hook."
  },
  "(border-colour: String or Colour, [String or Colour], [String or Colour], [String or Colour]) → Changer": {
    "prefix": ["b4r-colour:", "border-colour:"],
    "body": "(b4r-colour: \"${0:purple}\")",
    "description": "When applied to a hook being changed by the `(border:)` changer, this changes the border's colour."
  },
  "(border-size: Number, [Number], [Number], [Number]) → Changer": {
    "prefix": ["b4r-size:", "border-size:"],
    "body": "(b4r-size: \"${0:4}\")",
    "description": "When applied to a hook being changed by the `(border:)` changer, this multiplies the size of the border by a given amount."
  },
  "(corner-radius: Number, [Number], [Number], [Number]) → Changer": {
    "prefix": "corner-radius:",
    "body": "(corner-radius: \"${0:8}\")",
    "description": "When applied to a hook, this rounds the corners by the given number of pixels."
  },

  // colours

  "(hsl: Number, Number, Number, [Number]) → Colour": {
    "prefix": "hsl:",
    "body": "(hsl: ${1:300}, ${2:0.8}, ${3:0.5})",
    "description": "Creates a colour using the given hue (h) angle in degrees and the given saturation (s) and lightness (l) percentages."
  },
  "(hsla: Number, Number, Number, [Number]) → Colour": {
    "prefix": "hsla:",
    "body": "(hsla: ${1:300}, ${2:0.8}, ${3:0.5}, ${4:0.6})",
    "description": "Creates a colour using the given hue (h) angle in degrees, the given saturation (s) and lightness (l) percentages, and the transparency (alpha, or a) percentage."
  },
  "(rgb: Number, Number, Number, [Number]) → Colour": {
    "prefix": "rgb:",
    "body": "(rgb: ${1:240}, ${2:60}, ${3:120})",
    "description": "Creates a colour using the three red (r), green (g) and blue (b) values provided, whose values are numbers between 0 and 255."
  },
  "(rgba: Number, Number, Number, [Number]) → Colour": {
    "prefix": "rgba:",
    "body": "(rgba: ${1:240}, ${2:60}, ${3:120}, ${4:0.6})",
    "description": "Creates a colour using the three red (r), green (g) and blue (b) values provided (0..255), and, optionally, the transparency (alpha, or a) percentage (0.0..1.0)."
  },
  "(lch: Number, Number, Number, [Number]) → Colour": {
    "prefix": "lch:",
    "body": "(lch: ${1:0.6}, ${2:80}, ${3:10})",
    "description": "Creates a colour using three values in the CIELAB colour model: a lightness (l) percentage, a chroma (c) value, and a hue (h) angle in degrees."
  },
  "(lcha: Number, Number, Number, [Number]) → Colour": {
    "prefix": "lcha:",
    "body": "(lcha: ${1:0.6}, ${2:80}, ${3:10}, ${4:0.6})",
    "description": "Creates a colour using three values in the CIELAB colour model--a lightness (l) percentage, a chroma (c) value, and a hue (h) angle in degrees--and the transparency (alpha, or a) percentage."
  },
  "(complement: Colour) → Colour": {
    "prefix": "complement:",
    "body": "(complement: ${0:purple})",
    "description": "When given a colour, this provides a complement to that colour."
  },
  "(palette: String, Colour) → Array": {
    "prefix": "palette:",
    "body": "(palette: ${1|mono,adjacent,triad|}, ${0:purple})",
    "description": "When given a string specifying a palette type, and a colour, this macro produces an array containing the given colour and three additional colours that together form a palette."
  },
  "(gradient: Number, ...Number, Colour) → Gradient": {
    "prefix": "gradient:",
    "body": "(gradient: ${0}90, 0,#cc4488, 0.5,#cc6644, 1,#ffaa44)",
    "description": "When given a degree angle, followed by any number of number-colour pairs called 'colour stops', this macro produces a gradient that fades between those colours in the direction of the angle."
  },
  "(stripes: Number, Number, Colour, Colour) → Gradient": {
    "prefix": "stripes:",
    "body": "(stripes: ${1:degrees}, ${2:pixels}, ${3:colour1}, ${4:colour2})",
    "description": "When given a degree angle, a pixel distance, and two or more colours, this macro produces a gradient that draws a striped background."
  },
  "(mix: Number, Colour, Number, Colour) → Colour": {
    "prefix": "mix:",
    "body": "(mix: ${1:0.5, red}, ${2:0.5, blue})",
    "description": "When given two pairs of values--each a number from 0 to 1 and a colour--this macro produces a mix of the two colours, using the numbers as ratios of each colour."
  },

  // custom macros

  "(macro: [...TypedVar], CodeHook) → CustomMacro": {
    "prefix": "macro:",
    "body": [
      "(set: ${1:\\$macroName} to (macro: ${3:str-type ${2:_var}}, [",
      "\t$0",
      "]))"
    ],
    "description": "Construct your own custom macro and `(set:)` it into a variable."
  },
  "(output:) → Changer": {
    "prefix": ["out:", "output:"],
    "body": "(output:)[$0]",
    "description": "Used inside a `(macro:)` CodeHook to output the attached hook."
  },
  "(output-data: Any) → Instant": {
    "prefix": ["out-data:", "output-data:"],
    "body": "(output-data: $0)",
    "description": "Used inside a `(macro:)` CodeHook to output the value that the macro produces."
  },
  "(error: String) → Instant": {
    "prefix": "error:",
    "body": "(error: ${0:\"There's a problem\"})",
    "description": "Used inside a `(macro:)` to immediately produce an error with the given message string, and stops running any further code in the macro."
  },
  "(datatype: Any) → Datatype": {
    "prefix": "datatype:",
    "body": "(datatype: ${0:_anything})",
    "description": "Given any storeable value, returns a datatype that matches it."
  },
  "(datapattern: Any) → Any": {
    "prefix": "datapattern:",
    "body": "(datapattern: ${0:(a: 15, 45)})",
    "description": "Given an array or datamap, returns an array or datamap with its values replaced with their datatypes."
  },
  "(partial: String or CustomMacro, [...Any]) → CustomMacro": {
    "prefix": "partial:",
    "body": "(set: ${1:\\$fromZeroTo} to (partial: ${2:\"${3:range}\", ${4:0}}))",
    "description": "Given either the string name of a built-in macro, or a custom macro itself, followed by various values; returns a custom macro to serve as a shorthand for calling the given macro with those values, plus any additional values."
  },

  // data structures

  "(array: [...Any]) → Array": {
    "prefix": ["a:", "array:"],
    "body": "(a: ${0:\"gold\", \"frankincense\", \"myrrh\"})",
    "description": "Creates an array, which is an ordered collection of values."
  },
  "(datamap: [...Any]) → Datamap": {
    "prefix": ["dm:", "datamap:"],
    "body": "(dm: ${0:\"Cute\", 4, \"Wit\", 7})",
    "description": "Creates a datamap, which is a data structure that pairs string names with data values."
  },
  "(dataset: [...Any]) → Dataset": {
    "prefix": ["ds:", "dataset:"],
    "body": "(ds: ${0:\"gold\", \"frankincense\", \"myrrh\"})",
    "description": "Creates a dataset, which is an unordered collection of unique values."
  },
  "(all-pass: Lambda, [...Any]) → Boolean": {
    "prefix": ["all-pass:", "pass:"],
    "body": "(all-pass: ${1:_num where _num > 1}, ${3:...${2:\\$numbers}})",
    "description": "Given a `where` lambda and a series of values, this macro evaluates to true if the lambda, when run using each value, never evaluated to false."
  },
  "(altered: Lambda, [...Any]) → Array": {
    "prefix": "altered:",
    "body": "(altered: ${1:_n} via ${2:${1:_n}+1}, ${4:...${3:\\$numbers}})",
    "description": "Given a `via` lambda and a sequence of values, returns a new array with the same values in the same order, but altered by the lambda."
  },
  "(count: Array or String, ...Any) → Number": {
    "prefix": "count:",
    "body": "(count: ${1:\\$arrayOrString}, ${2:_searchTerm})",
    "description": "Given a string or array, followed by a value; returns the number of times any of the values are inside the string or array."
  },
  "(dm-altered: Lambda, Datamap) → Datamap": {
    "prefix": ["dm-altered:", "datamap-altered:"],
    "body": "(dm-altered: via ${1:its value + 10 where its name is not \"deltaZ\"}, ${2:(dm: \"deltaX\", 3, \"deltaY\", 6, \"deltaZ\", 9)})",
    "description": "Given a `via` lambda and a single datamap (with 'name' and 'value' datanames), returns a new datamap with the same datanames, but with its values altered by the lambda."
  },
  "(dm-entries: Datamap) → Array": {
    "prefix": ["dm-entries:", "data-entries:", "datamap-entries:"],
    "body": "(dm-entries: ${0:\\$datamap})",
    "description": "Given a datamap, returns an array of its name/value pairs, each as a datamap that only has 'name' and 'value' data."
  },
  "(dm-names: Datamap) → Array": {
    "prefix": ["dm-names:", "data-names:", "datamap-names:"],
    "body": "(dm-names: ${0:\\$datamap})",
    "description": "Given a datamap, returns an array of its data names, sorted alphabetically."
  },
  "(dm-values: Datamap) → Array": {
    "prefix": ["dm-values:", "data-values:", "datamap-values:"],
    "body": "(dm-values: ${0:\\$datamap})",
    "description": "Given a datamap, returns an array of its values, sorted alphabetically by their name."
  },
  "(find: Lambda, [...Any]) → Array": {
    "prefix": "find:",
    "body": "(find: _${1:person} where ${2:_${1:person} is not \"Alice\"}, ${4:...${3:\\$people}})",
    "description": "Searches through the given values, and produces an array of those which match the given search test. The test is expressed using a temp variable, the `where` keyword, and a boolean condition."
  },
  "(folded: Lambda, ...Any) → Any": {
    "prefix": "folded:",
    "body": "(folded: _{1:item} making _${3:total} via _${3:total} + _{1:item}'s ${2:attribute}, ${4:0}, ${6:...${5:\\$items}})",
    "description": "Given a `making` lambda and a sequence of values, returns a total value created by feeding every value in the sequence to the lambda. The first value after the lambda is put into the total, which is the variable inside the lambda's `making` clause, before running the lambda on the remaining values."
  },
  "(interlaced: Array, ...Array) → Array": {
    "prefix": "interlaced:",
    "body": "(interlaced: ${1:(a: \"A\", \"B\", \"C\")}, ${2:(a: 1, 2, 3)})",
    "description": "Given multiple arrays, pairs up each value in those arrays. Values with no matching pair are ignored."
  },
  "(none-pass: Lambda, ...Any) → Boolean": {
    "prefix": "none-pass:",
    "body": "(none-pass: ${1:_num where _num > 1}, ${3:...${2:\\$numbers}})",
    "description": "Given a `where` lambda and a series of values, this macro evaluates to true if the lambda, when run using each value, never evaluated to true."
  },
  "(permutations: ...Any) → Array": {
    "prefix": "permutations:",
    "body": "(permutations: ${2:...${1:\\$array}})",
    "description": "Given a sequence of values, returns an array containing each permutation of the order of those values, as arrays."
  },
  "(range: Number, Number) → Array": {
    "prefix": "range:",
    "body": "(range: ${1:1}, ${2:14})",
    "description": "Given `a` and `b`, returns an array containing an inclusive range of whole numbers from `a` to `b`, in ascending order."
  },
  "(repeated: Number, ...Any) → Array": {
    "prefix": "repeated:",
    "body": "(repeated: ${1:5}, ${0:\"hello\"})",
    "description": "Given a number and a sequence of values, returns an array containing those values repeated, in order, the given number of times."
  },
  "(reversed: [...Any]) → Array": {
    "prefix": "reversed:",
    "body": "(reversed: ${2:...${1:\\$array}})",
    "description": "Similar to `(a:)`, except this macro returns an array containing tje given elements in reverse order."
  },
  "(rotated-to: Lambda, [...Any]) → Array": {
    "prefix": "rotated-to:",
    "body": "(rotated-to: where ${1:it is > 3}, ${3:...${2:\\$numbers}})",
    "description": "Given a `where` lambda at the start, cycles the order of all subsequent values so that the first value to match the lambda is placed at the start."
  },
  "(rotated: Number, ...Any) → Array": {
    "prefix": "rotated:",
    "body": "(rotated: ${1:-2}, ${3:...${2:\\$array}})",
    "description": "Given a number at the start, moves each subsequent item forward by that number, wrapping back to the start if they pass the end of the array."
  },
  "(shuffled: ...Any) → Array": {
    "prefix": "shuffled:",
    "body": "(shuffled: ${1:\"mustard\", \"mayo\", \"salsa\"})",
    "description": "Returns an array of the given values, randomly rearranged."
  },
  "(some-pass: Lambda, ...Any) → Boolean": {
    "prefix": "some-pass:",
    "body": "(some-pass: ${1:_num where _num > 1}, ${3:...${2:\\$numbers}})",
    "description": "Given a `where` lambda and a series of values, this macro evaluates to true if the lambda, when run using each value, evaluated to true one or more times."
  },
  "(sorted: [Lambda], ...Any) → Array": {
    "prefix": "sorted:",
    "body": "(sorted: ${1:${2:via its name}, }${4:...${3:\\$creatures}})",
    "description": "Returns an array in which the values are sorted in English alphanumeric sort order."
  },
  "(subarray: Array, Number, Number) → Array": {
    "prefix": "subarray:",
    "body": "(subarray: ${1:\\$array}, ${2:3}, ${3:7})",
    "description": "Given an array and two numbers, returns a new array containing only the elements whose positions are between the two numbers, inclusive."
  },
  "(unique: ...Any) → Array": {
    "prefix": "unique:",
    "body": "(unique: ${2:...${1:\\$array}})",
    "description": "Given a sequence of values, returns an array containing each unique value once, in the order that they appeared."
  },
  "(unpack: ...VariableToValue) → Instant": {
    "prefix": "unpack:",
    "body": "(unpack: ${1:\\$coords} into ${2:(a: \\$x, \\$y, \\$z)})",
    "description": "Given multiple values in an array, datamap, or string, the keyword `into`, and a matching data structure, puts those values into containing variables at the positions of those values."
  },

  // date and time

  "(current-date:) → String": {
    "prefix": "current-date:",
    "body": "(current-date:)",
    "description": "Returns a string of the date on the current player's system clock, in the format 'Thu Jan 01 1970'."
  },
  "(current-time:) → String": {
    "prefix": "current-time:",
    "body": "(current-time:)",
    "description": "Returns a string of the 12-hour time on the current player's system clock, in the format '12:00 AM'."
  },
  "(monthday:) → Number": {
    "prefix": "monthday:",
    "body": "(monthday:)",
    "description": "Returns a number corresponding to the day of the month on the current player's system clock."
  },
  "(weekday:) → String": {
    "prefix": "weekday:",
    "body": "(weekday:)",
    "description": "Returns the name of the weekday (e.g. 'Monday', 'Tuesday') on the current player's system clock."
  },

  // debugging

  // (ignore:)
  // (test-true:)
  // (test-false:)
  "(assert: Boolean) → Instant": {
    "prefix": "assert:",
    "body": "(assert: ${1:\\$nails is <= \\$maxNails})",
    "description": "Given an expression, this debugging macro produces a helpful error whenever that expression evaluates to false."
  },
  "(assert-exists: HookName or String) → Command": {
    "prefix": "assert-exists:",
    "body": "(assert-exists: ${1|?bottomBar,\"the auroch\"|})",
    "description": "Given a hook name or passage text, produces a helpful error if that is not present in the current passage."
  },
  "(debug:) → Command": {
    "prefix": "debug:",
    "body": "(debug:)",
    "description": "This command, which takes no values, opens the Debug Mode panel if it wasn't open already."
  },
  "(mock-turns: Number) → Command": {
    "prefix": "mock-turns:",
    "body": "(mock-turns: ${0:3})",
    "description": "This debugging macro artificially increments the value of the `turns` keyword."
  },
  "(mock-visits: ...String) → Command": {
    "prefix": "mock-visits:",
    "body": "(mock-visits: ${0:\"Living Room\", \"Bedroom\", \"Kitchen\"})",
    "description": "This debugging macro artificially increments the value of the `visits` keyword for the given passage(s)."
  },
  "(verbatim-source: Any) → Command": {
    "prefix": ["v6m-source:", "verbatim-source:"],
    "body": "(v6m-source: ${0:(open-storylets:)'s 1st})",
    "description": "Prints out the Harlowe source code of any value given to it."
  },

  // game state

  "(history: [Lambda]) → Array": {
    "prefix": "history:",
    "body": "(history:${1: where its tags contains \"Forest\"})",
    "description": "Returns an array containing the string names of all passages the player has previously visited, in the order the player visited them. An optional lambda can filter by checking each `(passage:)` datamap."
  },
  "(visited: String or Lambda) → Boolean": {
    "prefix": "visited:",
    "body": "(visited: ${1|\"Cellar\",where its tags contains \"Forest\"|})",
    "description": "Returns true if the named passage, or any passage matching the `where` lambda, has ever been visited."
  },
  "(passage: [String]) → Datamap": {
    "prefix": "passage:",
    "body": "(passage:${1:\"${2:Cellar}\"})",
    "description": "Given a passage string name, returns a datamap of information about that passage. Given no name, returns information about the current passage."
  },
  "(passage:)'s": {
    "prefix": "passage's:",
    "body": "(passage:)'s",
    "description": "Queries the datamap of information about the current passage."
  },
  "(passages: [Lambda]) → Array": {
    "prefix": "passages:",
    "body": "(passages:${0: where its tags contains \"Forest\"})",
    "description": "Returns an array of datamaps containing information for all passages in the story, sorted by passage name, or for only certain passages that match the optional lambda."
  },
  "(forget-visits: Number) → Command": {
    "prefix": "forget-visits:",
    "body": "(forget-visits: ${0:-1})",
    "description": "'forgets' all visits that occurred before the given turn number."
  },
  "(forget-undos: Number) → Command": {
    "prefix": "forget-undos:",
    "body": "(forget-undos: ${0:-1})",
    "description": "'forgets' previous turns, preventing the player from using undo features (like `(link-undo:)`) to return to them."
  },
  "(metadata: [...Any]) → Metadata": {
    "prefix": "metadata:",
    "body": "(metadata: ${0:\"danger\", 4, \"rarity\", 5})",
    "description": "Adds the given names and values to the current passage's `(passage:)` datamap."
  },
  "(seed: String) → Command": {
    "prefix": "seed:",
    "body": "(seed: ${1|\"a1b2c3\",(current-date:)+(current-time:)|})",
    "description": "'fixes' Harlowe's random number generator, causing all random macros and features to output predetermined values based on the given 'seed' string."
  },

  // input and interface

  "(cycling-link: [Bind], ...String) → Command": {
    "prefix": "cycling-link:",
    "body": "(cycling-link: ${1:${2|bind,2bind|} ${3:\\$pressure}, }${0:\"Low\", \"Medium\", \"High\"})",
    "description": "This command, when evaluated, creates a cycling link: a link which does not go anywhere, but changes its own text to the next in a looping sequence of strings, setting the optional bound variable to match the string value of the text."
  },
  "(sequence-link: [Bind], ...String) → Command": {
    "prefix": ["seq-link:", "sequence-link:"],
    "body": "(seq-link: ${1:${2|bind,2bind|} ${3:\\$candy}, }${0:\"Two candies\", \"One candy\", \"Some wrappers\"})",
    "description": "Creates a link that does not go anywhere, but changes its own text to the next in a sequence of strings, becoming plain text once the final string is reached, and setting the optional bound variable to match the text at all times."
  },
  "(input: [Bind], [String], [String]) → Command": {
    "prefix": "input:",
    "body": "(input: ${1|\"delicious sandwich\",bind _playerName\\, \"=X=\"\\, \"Carmen SanDiego\",bind _spell|})",
    "description": "Creates a single-line text input element, allowing the player to input any amount of text without newlines, to optionally be automatically stored in a variable."
  },
  "(force-input: [Bind], [String], String) → Command": {
    "prefix": "force-input:",
    "body": "(force-input: ${1|bind _cmd\\, \"ERASE INTERNET\",bind _cmd\\, \"=X=\"\\, \"DEL WWW\",\"HELLO THERE\"|})",
    "description": "Creates a single-line text input element which appears to offer the player a means to input text, but instead replaces every keypress inside it with characters from a pre-set string."
  },
  "(input-box: [Bind], [String], [Number], [String]) → Command": {
    "prefix": "input-box:",
    "body": "(input-box: ${1:${2|bind,2bind|} ${3:\\$code}, }${4:\"${5:XXX=}\", }${6:${7:5}, }${8:\"${9:initial text}\"})",
    "description": "Creates a multi-line text input box of the given position, width (specified by the first, optional string) and height (specified by the optional number), allowing the player to input any amount of text, which can optionally be automatically stored in a variable. The final optional string specifies an initial default value for the box."
  },
  "(force-input-box: [Bind], [String], [Number], String) → Command": {
    "prefix": "force-input-box:",
    "body": "(force-input-box: ${1:${2|bind,2bind|} ${3:\\$code}, }${4:\"${5:XXX=}\", }${6:${7:5}, }${8:\"${9:forced text}\"})",
    "description": "Creates a multi-line text input box of the given position, width (specified by the first, optional string) and height (specified by the optional number), which appears to offer the player a means to input text, but instead replaces every keypress inside it with characters from a pre-set string."
  },
  "(checkbox: Bind, String) → Command": {
    "prefix": "checkbox:",
    "body": "(checkbox: ${1|bind,2bind|} ${2:\\$mode}, \"Hardcore\")",
    "description": "Creates a checkbox input, which sets the given bound variable to true or false, depending on its state."
  },
  "(checkbox-fullscreen: String) → Command": {
    "prefix": "checkbox-fullscreen:",
    "body": "(checkbox-fullscreen: ${1:\"Full Screen\"})",
    "description": "Creates a checkbox input, which toggles the browser's fullscreen mode and windowed mode. The checkbox will automatically update to match the browser's fullscreen status. If fullscreen mode cannot be entered, the checkbox will be disabled."
  },
  "(dropdown: Bind, ...String) → Command": {
    "prefix": "dropdown:",
    "body": "(dropdown: ${1|bind,2bind|} ${2:\\$title}, ${3:\"Duke\", \"King\", \"Emperor\"})",
    "description": "This command, when evaluated, creates a dropdown menu with the given strings as options. When an option is selected, the bound variable is set to match the string value of the text."
  },
  "(meter: Bind, Number, String, [String], [Colour or Gradient]) → Command": {
    "prefix": "meter:",
    "body": "(meter: ${1|bind,2bind|} ${2:\\$hitPoints}, ${3:\\$maxHP}, \"${4:=X=}\"${5:, \"${6:Hit Points}\"}${7:, ${8:red}})",
    "description": "Creates a horizontal bar-graph meter, showing the current value of a number variable, relative to a maximum value, and updating it whenever that variable changes."
  },

  // links

  "(link: String, [Changer]) → Changer": {
    "prefix": ["link:", "link-replace:"],
    "body": "(link: ${1:\"Stake\"})[${0:The dracula crumbles to dust.}]",
    "description": "When attached to a hook, this macro replaces the hook with a link that has the given text. The link, when clicked, vanishes and reveals the hook."
  },
  "(link-reveal: String, [Changer]) → Changer": {
    "prefix": ["link-reveal:", "link-append:"],
    "body": "(link-reveal: ${1:\"Heart\"})[${0:broken}]",
    "description": "When attached to a hook, this replaces the hook with a link that has the given text. The link, when clicked, reveals the hook and becomes plain, unstyled text."
  },
  "(link-repeat: String, [Changer]) → Changer": {
    "prefix": "link-repeat:",
    "body": "(link-repeat: ${1:\"Add cheese\"})[${0:(set:\\$cheese to it + 1)}]",
    "description": "When attached to a hook, this replaces the hook with a link that has the given text. The link, when clicked, reveals the hook. Further clicks will cause the hook to repeat itself."
  },
  "(link-rerun: String, [Changer]) → Changer": {
    "prefix": "link-rerun:",
    "body": "(link-rerun: ${1:\"Roll dice\"})[${0:You rolled a (random:1,6).}]",
    "description": "When attached to a hook, this replaces the hook with a link that has the given text. The link, when clicked, reveals the hook. Further clicks will cause the hook to rerun itself, as if by the effect of `(rerun:)`."
  },
  "(link-goto: String, [String]) → Command": {
    "prefix": "link-goto:",
    "body": "(link-goto: ${1:\"Enter the cellar\"}, ${0:\"Cellar\"})",
    "description": "Given a string of link text, and an optional destination passage name, creates a link that takes the player to another passage. The link functions identically to a standard link."
  },
  "(link-reveal-goto: String, [String], [Changer]) → Changer": {
    "prefix": "link-reveal-goto:",
    "body": "(link-reveal-goto: \"${1:Study English}\", \"${2:AfternoonClass}\")[${0:(set:\\$eng to it + 1)}]",
    "description": "Lets you run commands like `(set:)` just before going to another passage. The first string is the link text, and the second is the passage name. "
  },
  "(link-undo: String, [String]) → Command": {
    "prefix": "link-undo:",
    "body": "(link-undo: \"${1:Retreat}$0\"${2:, \"Can't retreat!\"})",
    "description": "Given a string of link text, produces a link that, when clicked, undoes the current turn and sends the player back to the previously visited passage. An optional second string can be provided, which is shown instead of the link if it's not possible to undo."
  },
  "(link-fullscreen: String, String, [String]) → Command": {
    "prefix": "link-fullscreen:",
    "body": "(link-fullscreen: \"${1:Fullscreen on}\", \"${2:Fullscreen off}\"${3:, \"${4:Fullscreen unavailable}\"})",
    "description": "Creates an automatically-updating link that, when clicked, toggles the browser's fullscreen mode and windowed modes. The first string is the link text used if the browser is currently in windowed mode; the second string for fullscreen mode. The optional third string is used when fullscreen mode isn't allowed by the browser."
  },
  "(link-show: String, ...HookName) → Command": {
    "prefix": "link-show:",
    "body": "(link-show: ${1:\"text\"}, ${2:?hookName})",
    "description": "Creates a link that, when clicked, shows the given hidden hooks, running the code within."
  },
  "(link-storylet: [String], Number or Lambda, [String]) → Command": {
    "prefix": "link-storylet:",
    "body": "(link-storylet: ${1:\"${2:Link text}\", }${3|1,where its tags contains \"episode\"|}${4:, \"${5:Unavailable}\"})",
    "description": "Creates a link to the first open storylet that matches the `where` lambda, or if a number `n` was passed in, the `n`th (or, if negative, `n`th-to-last) open storylet. The optional first string provides the link text; the default is the passage name of the storylet. The optional final string can provide text to display when no available storylet is open."
  },
  "(click: HookName or String, [Changer or Lambda]) → Changer": {
    "prefix": "click:",
    "body": "(click: ${1:\"dish of water\"})[${0:Your finger gets wet.}]",
    "description": "When attached to a hook, hides it and enchants the specified target such that it visually resembles a link; clicking it causes the attached hook to be revealed."
  },
  "(click-replace: HookName or String, [Changer or Lambda]) → Changer": {
    "prefix": "click-replace:",
    "body": "(click-replace: ${1:\"my deepest secret\"})[${0:my longing for you}]",
    "description": "Makes the specified hook replace its own text with that of the attached hook whenever the specified hook is clicked."
  },
  "(click-rerun: HookName or String, [Changer or Lambda]) → Changer": {
    "prefix": "click-rerun:",
    "body": "(click-rerun: ${1:\"this phrase\"})[${0:this hook}]",
    "description": "Creates a link on the specified hook or text (specified by the first value) that can be be activated multiple times to rerun the attached hook."
  },
  "(click-append: HookName or String, [Changer or Lambda]) → Changer": {
    "prefix": "click-append:",
    "body": "(click-append: ${1:?toThisHook})[${0:this content}]",
    "description": "Append the text of the attached hook to the specified hook or string when it's clicked."
  },
  "(click-goto: HookName or String, String) → Command": {
    "prefix": "click-goto:",
    "body": "(click-goto: ${1:\"click me\"}, \"${2:PassageName}\")",
    "description": "Makes the specified hook or bit of text into a passage link."
  },
  "(click-undo: HookName or String) → Command": {
    "prefix": "click-undo:",
    "body": "(click-undo: ${1:?page})",
    "description": "Makes a hook or bit of text into a passage link which undoes the current turn. `(click-undo: ?1)` is equivalent to `(click: ?1)[(undo: )]`."
  },
  "(click-prepend: HookName or String, [Changer or Lambda]) → Changer": {
    "prefix": "click-prepend:",
    "body": "(click-prepend: \"?\")[, seriously]",
    "description": "Prepend the text of the attached hook to the specified hook or string when it's clicked."
  },
  "(action: String) → Changer": {
    "prefix": "action:",
    "body": "(action: \"${1|mouseover,mouseout,doubleclick,click|}\")",
    "description": "When attached to a link command, or given to a link-changer macro as its second value, this macro turns the link into a different kind of interaction element with a different appearance."
  },

  // live

  "(live: [Number]) → Changer": {
    "prefix": "live:",
    "body": [
      "(live: ${1:0.5s})[",
      "\t${0:(either: \"Red!\", \"Green!\", \"Blue!\")}",
      "]"
    ],
    "description": "Makes the attached hook `live`, which means that it will rerun at the specified interval in milliseconds, replacing the source inside the hook with a newly computed version."
  },
  "(stop:) → Command": {
    "prefix": "stop:",
    "body": "(stop:)",
    "description": "This macro, which accepts no arguments, creates a (stop:) command which is not configurable."
  },
  "(event: Lambda) → Changer": {
    "prefix": "event:",
    "body": "(event: when ${1:time > ${2:10s}})[$0]",
    "description": "Hooks with this changer attached will only be run when the given condition becomes true."
  },
  "(after: Number, [Number]) → Changer": {
    "prefix": "after:",
    "body": "(after: time + ${1:3s})[$0]",
    "description": "Hooks with this changer attached will only be run once the specified amount of time has passed since the passage was rendered. An optional second number reduces the delay by that amount when the player holds down a keyboard key or mouse button, or touches the touch device."
  },
  "(after-error:) → Changer": {
    "prefix": "after-error:",
    "body": "(after-error:)[${0:Oops! Something broke!}]",
    "description": "This bug-specific macro hides its attached the hook and only runs it once an error occurs."
  },
  "(more:) → Changer": {
    "prefix": "more:",
    "body": "(more:)[$0]",
    "description": "Hooks with this changer attached will only be run once no other exits--links and `(click:)`-enchanted areas--are remaining in the passage, and will reveal `more` prose."
  },

  // maths

  "(abs: Number) → Number": {
    "prefix": "abs:",
    "body": "(abs: ${0:-4})",
    "description": "This maths macro returns the absolute value (without the sign) of the given number."
  },
  "(cos: Number) → Number": {
    "prefix": "cos:",
    "body": "(cos: ${0:3.14159265})",
    "description": "This maths macro returns the cosine of the given number of radians."
  },
  "(exp: Number) → Number": {
    "prefix": "exp:",
    "body": "(exp: ${0:6})",
    "description": "This maths macro raises Euler's number to the power of the given number, and returns the result."
  },
  "(log: Number) → Number": {
    "prefix": "log:",
    "body": "(log: ${0:(exp:5)})",
    "description": "This maths macro returns the natural (base-e) logarithm of the given number."
  },
  "(log10: Number) → Number": {
    "prefix": "log10:",
    "body": "(log10: ${0:100})",
    "description": "This maths macro returns the base-10 logarithm of the given number."
  },
  "(log2: Number) → Number": {
    "prefix": "log2:",
    "body": "(log2: ${0:256})",
    "description": "This maths macro returns the base-2 logarithm of the given number."
  },
  "(max: ...Number) → Number": {
    "prefix": "max:",
    "body": "(max: ${2:...${1:\\$numbers}})",
    "description": "This maths macro returns the highest valued of the given numbers."
  },
  "(min: ...Number) → Number": {
    "prefix": "min:",
    "body": "(min: ${2:...${1:\\$numbers}})",
    "description": "This maths macro returns the lowest valued of the given numbers."
  },
  "(pow: Number, Number) → Number": {
    "prefix": "pow:",
    "body": "(pow: ${1:2}, ${2:8})",
    "description": "This maths macro raises the first number to the power of the second number, and returns the result."
  },
  "(sign: Number) → Number": {
    "prefix": "sign:",
    "body": "(sign: ${0:-4})",
    "description": "This maths macro returns -1 when given a negative number, 0 when given 0, and 1 when given a positive number."
  },
  "(sin: Number) → Number": {
    "prefix": "sin:",
    "body": "(sin: ${0:3.14159265 / 2})",
    "description": "This maths macro returns the sine of the given number of radians."
  },
  "(sqrt: Number) → Number": {
    "prefix": "sqrt:",
    "body": "(sqrt: ${0:81})",
    "description": "This maths macro returns the square root of the given number."
  },
  "(tan: Number) → Number": {
    "prefix": "tan:",
    "body": "(tan: ${0:3.14159265 / 4})",
    "description": "This maths macro returns the tangent of the given number of radians."
  },

  // navigation

  "(go-to: String) → Command": {
    "prefix": ["goto:", "go-to:"],
    "body": "(goto: ${1:\"${2:Basement}\"})",
    "description": "Stops passage code and sends the player to a new passage, starting a new turn as if a passage link was clicked."
  },
  "(redirect: String) → Command": {
    "prefix": "redirect:",
    "body": "(redirect: ${1:\"${2:Basement}\"})",
    "description": "Stops passage code and sends the player to a new passage, but does not start a new turn. Undoing after this will send the player to the turn before the redirect occurred."
  },
  "(undo: [String]) → Command": {
    "prefix": "undo:",
    "body": "(undo:${1: \"${2:Not available}\"})",
    "description": "Stops passage code and undoes the current turn, sending the player to the previously visited passage and forgetting any variable changes that occurred in this passage. The optional string is displayed if undos aren't available."
  },
  "(restart:) → Command": {
    "prefix": ["restart:", "reload:"],
    "body": "(restart:)",
    "description": "When this command is used, the player's browser will immediately attempt to reload the page, in effect restarting the entire story."
  },

  // numbers

  "(ceil: Number) → Number": {
    "prefix": "ceil:",
    "body": "(ceil: ${0:1.1})",
    "description": "Rounds the given number upward to a whole number. If a whole number is provided, it returns the number as-is."
  },
  "(floor: Number) → Number": {
    "prefix": "floor:",
    "body": "(floor: ${0:1.99})",
    "description": "Rounds the given number downward to a whole number. If a whole number is provided, it returns the number as-is."
  },
  "(num: String) → Number": {
    "prefix": "num:",
    "body": "(num: ${0:\"25\"})",
    "description": "Converts strings to numbers by reading the digits in the entire string. It can handle decimal fractions and negative numbers."
  },
  "(random: Number, [Number]) → Number": {
    "prefix": "random:",
    "body": "(random: ${1:1}, ${2:20})",
    "description": "Returns a randomly selected integer between the two given integers (or, if the second number is absent, between 0 and the first number), inclusive."
  },
  "(round: Number) → Number": {
    "prefix": "round:",
    "body": "(round: ${0:1.5})",
    "description": "Rounds the given number to the nearest whole number: downward if its decimals are smaller than 0.5, and upward otherwise. If a whole number is provided, it returns the number as-is."
  },
  "(trunc: Number) → Number": {
    "prefix": "trunc:",
    "body": "(trunc: ${0:1.5})",
    "description": "Rounds the given number towards zero by truncating the fractional portion of the number, leaving just the whole portion."
  },

  // patterns

  "(p: ...String or Datatype) → Datatype": {
    "prefix": ["p:", "pattern:"],
    "body": "(p: $0)",
    "description": "Creates a string pattern, a special kind of datatype that can match complex string structures. The pattern matches the entire sequence of strings or datatypes given, in order."
  },
  "(p-either: ...String or Datatype) → Datatype": {
    "prefix": ["p-either:", "pattern-either:"],
    "body": "(p-either: ${2:...${1:\\$array}})",
    "description": "Creates a string pattern that matches any of the single strings or datatypes given."
  },
  "(p-opt: ...String or Datatype) → Datatype": {
    "prefix": ["p-opt:", "pattern-opt:", "p-optional:", "pattern-optional:"],
    "body": "(p-opt: ${0:\"Default Name\"})",
    "description": "Creates a string pattern that either matches the sequence of strings or datatypes given, or the empty string."
  },
  "(p-many: [Number], [Number], ...String or Datatype) → Datatype": {
    "prefix": ["p-many:", "pattern-many:"],
    "body": "(p-many: ${1:${2:3},${3:12},}${0:lowercase})",
    "description": "Creates a string pattern that matches the given sequence of strings and datatypes, repeated the given minimum and maximum number of times--or, if these aren't provided, repeated any number of times."
  },
  "(p-not: ...String or Datatype) → Datatype": {
    "prefix": ["p-not:", "pattern-not:"],
    "body": "(p-not: $0)",
    "description": "Given any number of single characters or non-spread datatypes, this creates a string pattern that matches any one character that doesn't match any of those values."
  },
  "(p-before: ...String or Datatype) → Datatype": {
    "prefix": ["p-before:", "pattern-before:"],
    "body": "(p-before: $0)",
    "description": "Creates a string pattern that matches the empty string *only* if it is followed by the given sequence of strings or datatypes."
  },
  "(p-not-before: ...String or Datatype) → Datatype": {
    "prefix": ["p-not-before:", "pattern-not-before:"],
    "body": "(p-not-before: $0)",
    "description": "Creates a string pattern that matches the empty string *unless* it is followed by the given sequence of strings or datatypes."
  },
  "(p-start: ...String or Datatype) → Datatype": {
    "prefix": ["p-start:", "pattern-start:"],
    "body": "(p-start: $0)",
    "description": "Identical to `(p:)`, except that when used with macros that search for substrings in strings, like `(str-find:)`, `(str-replaced:)` and `(trimmed:)`, this only matches if the given strings or datatypes appear at the very start of the string."
  },
  "(p-end: ...String or Datatype) → Datatype": {
    "prefix": ["p-end:", "pattern-end:"],
    "body": "(p-end: $0)",
    "description": "Identical to `(p:)`, except that when used with macros that search for substrings in strings, like `(str-find:)`, `(str-replaced:)` and `(trimmed:)`, this only matches if the given strings or datatypes appear at the very end of the string."
  },
  "(p-ins: ...String or Datatype) → Datatype": {
    "prefix": [
      "p-ins:",
      "pattern-ins:",
      "p-insensitive:",
      "pattern-insensitive:"
    ],
    "body": "(p-ins: $0)",
    "description": "Creates a string pattern that matches the sequence of strings or datatypes given, case-insensitively."
  },

  // popup

  "(dialog: [Bind], String or CodeHook, ...String) → Command": {
    "prefix": ["dialog:", "alert:"],
    "body": "(dialog: ${1:bind ${2:$$favColour}, }[${3:Favourite colour?}], ${4:\"Orange\", \"Magenta\", \"Aqua\"})",
    "description": "Displays a pop-up dialog box with the given string or codehook displayed, and a number of button-shaped links labeled with the remaining other strings. If an optional bound variable is provided, that variable is updated to match the pressed button."
  },
  "(confirm: String or CodeHook, [String], [String]) → Boolean": {
    "prefix": "confirm:",
    "body": "(set: ${1:\\$makeCake} to (confirm: [${2:Transform your best friend into a cake?}$0]${3:, \"${4:Cancel}\", \"${5:OK}\"}))",
    "description": "Creates a pop-up dialog box with the given string displayed, as well as two links to confirm or cancel the statement. When submitted, it evaluates to the boolean `true` if the confirm link had been clicked, and `false` if the cancel link had."
  },
  "(prompt: String or CodeHook, String, [String], [String]) → String": {
    "prefix": "prompt:",
    "body": "(set: ${1:\\$name} to (prompt: [${2:What is your name?}$0], \"Jane Doe\"${3:, \"${4:Cancel}\", \"${5:OK}\"}))",
    "description": "Creates a browser pop-up dialog box with the first string displayed, a text entry box containing the second string(as a default value, a confirm link, and a cancel link. If the confirm link is clicked, it evaluates to the string in the text entry box. If the cancel link is clicked, it evaluates to the default value, regardless of the entry box's contents."
  },

  // revision

  "(replace: ...HookName or String) → Changer": {
    "prefix": "replace:",
    "body": "(replace: ${1|\"cat\",?pet|})[$0]",
    "description": "Replaces the given target with the contents of the attached hook."
  },
  "(append: ...HookName or String) → Changer": {
    "prefix": "append:",
    "body": "(append: ${1|\"string\",?hookName|})[$0]",
    "description": "Appends the contents of the attached hook to the given target."
  },
  "(prepend: ...HookName or String) → Changer": {
    "prefix": "prepend:",
    "body": "(prepend: ${1|\"string\",?hookName|})[$0]",
    "description": "Prepends the contents of the attached hook to the given target."
  },
  "(replace-with: String or CodeHook) → Changer": {
    "prefix": "replace-with:",
    "body": "(replace-with: ${1|\"string\",[CodeHook]|})",
    "description": "Replaces the entirety of the attached hook with the contents of the given string or CodeHook."
  },
  "(append-with: String or CodeHook) → Changer": {
    "prefix": "append-with:",
    "body": "(append-with: ${1|\"string\",[CodeHook]|})",
    "description": "Appends the contents of the given target to the attached hook."
  },
  "(prepend-with: String or CodeHook) → Changer": {
    "prefix": "prepend-with:",
    "body": "(prepend-with: ${1|\"string\",[CodeHook]|})",
    "description": "Prepends the contents of the given target to the attached hook."
  },
  "(rerun: ...HookName) → Command": {
    "prefix": "rerun:",
    "body": "(rerun: ${1:?${2:hookName}})",
    "description": "Reruns the given hooks, restoring them to their original contents, and running the macros within them again."
  },

  // saving

  "(load-game: String) → Command": {
    "prefix": "load-game:",
    "body": "(load-game: ${1:\"${2:Slot A}\"})",
    "description": "Attempts to load a saved game from the specified slot, ending the current game and replacing it with the loaded one, completely and instantly replacing the variables and move history with that of the save, and going to the passage where that save was made."
  },
  "(save-game: String, [String]) → Boolean": {
    "prefix": "save-game:",
    "body": "(if:(save-game:${1:\"${2:Slot A}\"}))[${3:Game saved!}](else:)[${4:Save failed!}]",
    "description": "Saves the current game's state in browser storage, in the specified save slot, with an optionally specified filename. It can then be restored using (load-game:)."
  },
  "(saved-games:) → Datamap": {
    "prefix": "saved-games:",
    "body": "(saved-games:)",
    "description": "Returns a datamap containing the names of currently occupied save game slots."
  },

  // showing and hiding

  "(hidden:) → Changer": {
    "prefix": "hidden:",
    "body": "(hidden:)${1:[$0]}",
    "description": "Returns a changer that will hide any attached hook."
  },
  "(hide: ...HookName) → Command": {
    "prefix": "hide:",
    "body": "(hide: ${1:?${2:hookName}})",
    "description": "Hides a visible hook or hooks without fully erasing them or their contained macro calls."
  },
  "(show: ...HookName) → Command": {
    "prefix": "show:",
    "body": "(show: ${1:?${2:hookName}})",
    "description": "Reveals a hidden hook or hooks, running the code within if it hasn't been shown yet."
  },

  // sidebar

  "(icon-undo: [String], [String]) → Command": {
    "prefix": "icon-undo:",
    "body": "(icon-undo: ${1|\"←\",\"Undo\",\"←\"\\, \"Undo\"|})",
    "description": "Create an icon that, if visible and clicked, undoes the current turn and returns to the previous passage, as if by `(undo:)`."
  },
  "(icon-redo: [String], [String]) → Command": {
    "prefix": "icon-redo:",
    "body": "(icon-redo: ${1|\"→\",\"Redo\",\"→\"\\, \"Redo\"|})",
    "description": "Create an icon that, if visible and clicked, redoes a turn that was undone."
  },
  "(icon-fullscreen: [String], [String]) → Command": {
    "prefix": "icon-fullscreen:",
    "body": "(icon-fullscreen: ${1|\"⛶\",\"Fullscreen\",\"⛶\"\\, \"Fullscreen\"|})",
    "description": "Create an icon that, if visible and clicked, toggles fullscreen mode."
  },
  "(icon-restart: [String]) → Command": {
    "prefix": "icon-restart:",
    "body": "(icon-restart: ${1|\"⟲\",\"Restart\",\"⟲\"\\, \"Restart\"|})",
    "description": "Create an icon that, if visible and clicked, reloads the whole page, restarting the story from the beginning."
  },
  "(icon-counter: Bind, String, [String]) → Command": {
    "prefix": "icon-counter:",
    "body": "(icon-counter: bind ${1:\\$mouseCount}, \"${2:mouse}\"${3:, \"${4:mice}\"})",
    "description": "Creates a numeric counter element with a text label, designed to fit in the sidebar, displaying the contents of a number variable (rounded by `(trunc:)`), and updating it whenever another macro changes the value."
  },

  // storylets

  "(storylet: Lambda) → Metadata": {
    "prefix": "storylet:",
    "body": "(storylet: ${0:when \\$hour is 12})",
    "description": "When placed in a passage, this macro marks that passage as the beginning of a storylet, using the lambda as the condition upon which it's available to the player."
  },
  "(open-storylets: [Lambda]) → Array": {
    "prefix": "open-storylets:",
    "body": "(open-storylets: ${0:where its tags contains \"quest\"})",
    "description": "Returns an array of datamaps for every passage whose `(storylet:)` lambda produced true, sorted by their 'urgency' metadata value, then by passage name; filtered by the optional lambda."
  },
  "(exclusivity: Number) → Metadata": {
    "prefix": "exclusivity:",
    "body": "(exclusivity: ${0:2})",
    "description": "Marks the current passage as being more or less exclusive, meaning that if it's open, it will prevent storylets with lesser exclusivity from appearing in `(open-storylets:)`."
  },
  "(urgency: Number) → Metadata": {
    "prefix": "urgency:",
    "body": "(urgency: ${0:2})",
    "description": "Marks the current passage as being more or less urgent, meaning that `(open-storylets:)` will sort it earlier or later than other passages."
  },

  // strings

  "(str: ...[Number or String or Boolean or Array]) → String": {
    "prefix": ["str:", "string:", "text:"],
    "body": "(str: $0)",
    "description": "Accepts any amount of values and tries to convert them all to a single String."
  },
  "(digit-format: String, Number) → String": {
    "prefix": "digit-format:",
    "body": "(digit-format: \"${1:##.##}$0\", ${2:35.3})",
    "description": "Given a special formatting string, followed by a number, this macro converts the number into a string using the formatter as a guide."
  },
  "(joined: ...String) → String": {
    "prefix": "joined:",
    "body": "(joined: ${1:\"-\"}, ${3:...${2:\\$strings}})",
    "description": "Using the first string as a separator value, this macro takes all of the other strings given to it, and joins them into a single string."
  },
  "(lowercase: String) → String": {
    "prefix": "lowercase:",
    "body": "(lowercase: \"$0\")",
    "description": "Produces a lowercase version of the given string."
  },
  "(lowerfirst: String) → String": {
    "prefix": "lowerfirst:",
    "body": "(lowerfirst: \"$0\")",
    "description": "Produces a version of the given string, where the first alphanumeric character is lowercase, and other characters are left as-is."
  },
  "(plural: Number, String, [String]) → String": {
    "prefix": "plural:",
    "body": "(plural: ${1:2}, \"${2:elf}\"${3:, \"${4:elves}\"})",
    "description": "Given a whole number and a string, converts the number to a string, joins them up with a space character, and pluralises the string if the number wasn't 1 or -1."
  },
  "(source: Any) → String": {
    "prefix": "source:",
    "body": "(source: ${1|\\$voltage,(str-repeated: 6\\, \"HA\"),(click: ?hat),(enchant: ?passage's hooks\\, \\$style)|}$0)",
    "description": "Given almost any data value, this will produce a string representation of Harlowe source code that can, when run, create that value exactly."
  },
  "(split: String or Datatype, String) → Array": {
    "prefix": ["split:", "splitted:"],
    "body": "(split: ${1:\"-\"}, ${2:(passage:)'s name})",
    "description": "Splits the second given value into an array of substrings as separated by the first string/pattern."
  },
  "(str-find: Datatype, String) → Array": {
    "prefix": ["str-find:", "string-find:"],
    "body": "(str-find: ${1:_pattern}, ${2:_string})",
    "description": "Given a string pattern and a string, this macro produces an array of every matching substring within the string."
  },
  "(str-nth: Number) → String": {
    "prefix": ["str-nth:", "string-nth:"],
    "body": "(str-nth:${1:_num})",
    "description": "Given a whole number, converts it to a string comprising an English ordinal abbreviation (e.g. '1st', '22nd', etc.)"
  },
  "(str-repeated: Number, String) → String": {
    "prefix": ["str-repeated:", "string-repeated:"],
    "body": "(str-repeated: ${1:_num}, ${2:_string})",
    "description": "This accepts a single string and duplicates it the given number of times."
  },
  "(str-replaced: [Number], String or Datatype, String or Lambda, String) → String": {
    "prefix": ["str-replaced:", "string-replaced:", "replaced:"],
    "body": "(str-replaced: ${1:${2:1}, }${3:_fromThing}, ${4:_toThing}, ${5:\"subject\"})",
    "description": "Return a copy of the last string given, with all instances of the first specified search string (or pattern) replaced with the second specified string (or altered by a `via` lambda that constructs a replacement string). Specifying an optional number `n` replaces only the first `n` instances."
  },
  "(str-reversed: String) → String": {
    "prefix": ["str-reversed:", "string-reversed:"],
    "body": "(str-reversed: \"$0\")",
    "description": "Reverses the given string. (.gnirts nevig eht sesreveR)"
  },
  "(substring: String, Number, Number) → String": {
    "prefix": "substring:",
    "body": "(substring: \"$0\", ${1:3}, ${2:5})",
    "description": "Returns a substring of the given string from the two (inclusive) number positions."
  },
  "(trimmed: [String or Datatype], String) → String": {
    "prefix": "trimmed:",
    "body": "(trimmed: ${1:${2:whitespace}, }\"$0\")",
    "description": "Given one string (the last value), returns a copy with every character matching the given pattern (the first value) removed from its start and end. If no first argument is given, it defaults to the `whitespace` pseudo-datatype."
  },
  "(uppercase: String) → String": {
    "prefix": "uppercase:",
    "body": "(uppercase: \"$0\")",
    "description": "Produces an uppercase version of the given string."
  },
  "(upperfirst: String) → String": {
    "prefix": "upperfirst:",
    "body": "(upperfirst: \"$0\")",
    "description": "Produces a version of the given string where the first alphanumeric character is uppercase, and other characters are left as-is."
  },
  "(words: String) → Array": {
    "prefix": "words:",
    "body": "(words: \"$0\")",
    "description": "Given a string, returns an array of each word (i.e. sequence of non-whitespace characters) in that string."
  },

  // styling

  "(align: String) → Changer": {
    "prefix": "align:",
    "body": "(align: \"${1|==>,=><=,<==>,<==|}\")[$0]",
    "description": "This styling changer changes the alignment of text in the attached hook."
  },
  "(bg: Colour or String or Gradient) → Changer": {
    "prefix": ["background:", "bg:"],
    "body": "(bg: ${1|red,#ff0000,\"#ff0000\"|})[$0]",
    "description": "This styling changer alters the background colour or background image of the attached hook."
  },
  "(box: String, [Number]) → Changer": {
    "prefix": "box:",
    "body": "(box: \"${1:=XX=}\"${2:, ${3:3}})[$0]",
    "description": "This macro's attached hook becomes a 'box', with a given width proportional to the containing element's width, an optional number of lines tall, and a scroll bar if the text inside is longer than its height can contain."
  },
  "(button: [String]) → Changer": {
    "prefix": "button:",
    "body": "(button:${1: \"${2:=XXXX=}\"})[[$0]]",
    "description": "This changer styles the attached link so it resembles a button. The optional sizing string lets you specify width and horizontal margins for the button."
  },
  "(char-style: Changer or Lambda) → Changer": {
    "prefix": "char-style:",
    "body": "(char-style: ${1|(text-style: \"fidget\"),via (text-colour: (either: red\\,white\\,blue))|})[$0]",
    "description": "Styles all of the individual non-whitespace characters inside the hook (those that would be selected by `?page's chars`) using the specified changer."
  },
  "(collapse:) → Changer": {
    "prefix": "collapse:",
    "body": "(collapse:)${1:[$0]}",
    "description": "Collapses all whitespace within the attached hook, in the same manner as the {collapsing whitespace} markup."
  },
  "(css: String) → Changer": {
    "prefix": "css:",
    "body": "(css: \"${1:background-color:indigo;}\")[${0:styled text}]",
    "description": "Given a string of inline CSS, applies it to the attached hook, as if it were a HTML `style` property."
  },
  "(float-box: String, String) → Changer": {
    "prefix": "float-box:",
    "body": "(float-box: \"${1:X====}\",\"${2:Y====}\")[$0]",
    "description": "This macro's attached hook becomes a floating box, placed at a given spot in the window, sized proportionally to the window's dimensions, and with a scroll bar if the text inside is longer than its height can contain."
  },
  "(font: String) → Changer": {
    "prefix": "font:",
    "body": "(font: \"${1:Helvetica Neue}\")[$0]",
    "description": "This styling changer changes the font used to display the text of the attached hook."
  },
  "(hook: String) → Changer": {
    "prefix": "hook:",
    "body": "(hook: ${1:\\$name})[$0]",
    "description": "Gives the attached hook the specified (computed) nametag."
  },
  "(hover-style: Changer) → Changer": {
    "prefix": "hover-style:",
    "body": "(hover-style: ${1:(text-style: \"italic\")})",
    "description": "Given a style-altering changer, returns a changer which only applies when the attached hook or command is hovered over with the mouse pointer, and is removed when hovering off."
  },
  "(line-style: Changer or Lambda) → Changer": {
    "prefix": "line-style:",
    "body": "(line-style: ${1:(b4r: \"dotted\")})[$0]",
    "description": "Styles all lines of prose inside the attached hook using the specified changer."
  },
  "(link-style: Changer or Lambda) → Changer": {
    "prefix": "link-style:",
    "body": "(link-style: ${1:(b4r: \"dotted\")})[$0]",
    "description": "Styles all of the links inside the attached hook using the specified changer."
  },
  "(opacity: Number) → Changer": {
    "prefix": "opacity:",
    "body": "(opacity: ${1:0.5})[$0]",
    "description": "Changes the opacity of the attached hook to a value between 0 and 1 (0 is invisible, 1 is fully opaque)."
  },
  "(text-colour: String or Colour) → Changer": {
    "prefix": ["colour:", "text-color:", "color:", "text-colour:"],
    "body": "(colour: ${1|red,orange,yellow,lime,green,aqua,cyan,blue,navy,purple,magenta,fuchsia,white,black,grey,gray,transparent|})[$0]",
    "description": "Changes the colour used by the text in the attached hook."
  },
  "(text-indent: Number) → Changer": {
    "prefix": "text-indent:",
    "body": "(text-indent: ${1:16})[$0]",
    "description": "Indents the attached hook by the given number of pixels."
  },
  "(text-rotate-x: Number) → Changer": {
    "prefix": "text-rotate-x:",
    "body": "(text-rotate-x: ${1:-45})[$0]",
    "description": "Visually rotates the attached hook clockwise around the X axis (horizontal) by the given number of degrees, making it appear to lean into the page."
  },
  "(text-rotate-y: Number) → Changer": {
    "prefix": "text-rotate-y:",
    "body": "(text-rotate-y: ${1:45})[$0]",
    "description": "Visually rotates the attached hook clockwise around the Y axis (vertical) by the given number of degrees, making it appear to lean into the page."
  },
  "(text-rotate-z: Number) → Changer": {
    "prefix": ["text-rotate:", "text-rotate-z:"],
    "body": "(text-rotate: ${1:45})[$0]",
    "description": "Visually rotates the attached hook clockwise by a given number of degrees."
  },
  "(text-size: Number) → Changer": {
    "prefix": ["size:", "text-size:"],
    "body": "(text-size: ${1:1.5})[$0]",
    "description": "Changes the text size of the attached hook by the given fraction. Numbers greater than 1 enlarge the text; numbers less than 1 shrink it."
  },
  "(text-style: ...String) → Changer": {
    "prefix": "text-style:",
    "body": "(text-style: \"${1|none,bold,italic,underline,double-underline,wavy-underline,strike,double-strike,wavy-strike,superscript,subscript,blink,shudder,mark,condense,expand,outline,shadow,emboss,smear,blur,blurrier,mirror,upside-down,tall,flat,fade-in-out,rumble,sway,buoy,fidget|}\")",
    "description": "Applies one or more selected built-in text styles to the attached hook's text."
  },

  // transitions

  "(transition: String) → Changer": {
    "prefix": ["t8n:", "transition:"],
    "body": "(t8n: \"${1|instant,dissolve,fade,rumble,shudder,pulse,zoom,flicker,slide-left,slide-right,slide-up,slide-down,fade-left,fade-right,fade-up,fade-down|}\")[$0]",
    "description": "Applies a built-in CSS transition to a hook as it appears."
  },
  "(transition-delay: Number) → Changer": {
    "prefix": ["t8n-delay:", "transition-delay:"],
    "body": "(t8n-delay: ${0:3s})+",
    "description": "When added to a `(transition:)` changer, delays the start of the transition by a given time."
  },
  "(transition-time: Number) → Changer": {
    "prefix": ["t8n-time:", "transition-time:"],
    "body": "(t8n-time: ${0:3s})+",
    "description": "When added to a `(transition:)` changer, adjusts the time of the transition."
  },
  "(transition-depart: String) → Changer": {
    "prefix": ["t8n-depart:", "transition-depart:"],
    "body": "(t8n-depart: \"${1|instant,dissolve,fade,rumble,shudder,pulse,zoom,flicker,slide-left,slide-right,slide-up,slide-down,fade-left,fade-right,fade-up,fade-down|}\")",
    "description": "Alters the fade-out animation of passage links, `(link-goto:)` links, and most every other kind of link."
  },
  "(transition-arrive: String) → Changer": {
    "prefix": ["t8n-arrive:", "transition-arrive:"],
    "body": "(t8n-arrive: \"${1|instant,dissolve,fade,rumble,shudder,pulse,zoom,flicker,slide-left,slide-right,slide-up,slide-down,fade-left,fade-right,fade-up,fade-down|}\")",
    "description": "Alters the fade-in animation of passage links, `(link-goto:)` links, and most every other kind of link."
  },
  "(transition-skip: Number) → Changer": {
    "prefix": ["t8n-skip:", "transition-skip:"],
    "body": "(t8n-skip: ${0:0.5s})",
    "description": "When added to a `(transition:)` changer, allows the player to skip or accelerate the transition by holding down a keyboard key or mouse button, or by touching the touch device."
  },
  "(animate: HookName, String, [Number]) → Command": {
    "prefix": "animate:",
    "body": "(animate: ${1:?hookName}, \"${2|instant,dissolve,fade,rumble,shudder,pulse,zoom,flicker,slide-left,slide-right,slide-up,slide-down,fade-left,fade-right,fade-up,fade-down|}\"${3:, ${4:5s}})",
    "description": "Briefly animates the attached hook as if a `(transition:)` was applied to it. The length of the animation can be optionally specified."
  },

  // window

  "(goto-url: String) → Command": {
    "prefix": "goto-url:",
    "body": "(goto-url: \"${1:http://example.org}\")",
    "description": "When this command is used, the player's browser will immediately attempt to leave the story's page and navigate to the given URL in the same tab. If this succeeds, then the story session will end."
  },
  "(open-url: String) → Command": {
    "prefix": "open-url:",
    "body": "(open-url: \"${1:http://example.org}\")",
    "description": "When this command is used, the player's browser will immediately attempt to open a new tab with the given URL. This will usually require confirmation from the player; most browsers block JavaScript from opening tabs by default."
  },
  "(page-url:) → String": {
    "prefix": "page-url:",
    "body": "(page-url:)",
    "description": "Produces the full URL of the story's HTML page, as it is in the player's browser."
  },
  "(scroll: HookName, Number or HookName) → Command": {
    "prefix": "scroll:",
    "body": "(scroll: ${1:?hookName}, ${2:0.5s})",
    "description": "Given a HookName followed by a fraction between 0 and 1, will change the scroll position of every hook with that name to the percentage of its height signified by the fraction. Given a second HookName, will scroll the first hook until the second is visible."
  },

  // not macros

  "Named hook": {
    "prefix": ">hook",
    "body": "|${1:hook}>[$0]",
    "description": "A visible hook with an attached nametag."
  },
  "Named hidden hook": {
    "prefix": ")hook",
    "body": "|${1:hook})[$0]",
    "description": "A hidden hook with an attached nametag."
  },
  "New passage": {
    "prefix": "::newpass",
    "body": [
      ":: ${1:PassageName}${2: [${3|tags,header,footer,startup,script,stylesheet,debug-header,debug-footer,debug-startup|}]}",
      "$0"
    ],
    "description": "A new empty passage with optional tag(s)."
  },
  "StoryData passage": {
    "prefix": "::storydata",
    "body": [
      ":: StoryData\n{",
      "\t\"ifid\": \"$UUID\",",
      "\t\"format\": \"Harlowe\",",
      "\t\"format-version\": \"3.3.6\",",
      "\t\"start\": \"Start\",",
      "\t\"zoom\": 1",
      "}\n\n"
    ],
    "description": "JSON to populate the `StoryData` passage expected by Twine."
  }
}
